#### 容易出错的js

// 1. 字符串和数字相加的话会变成字符和字符的相加

for(var i=0 ; i< 10; i++){
    var msg = 'hello' + i* 2 +i;
    console.log(msg);
    /*分别是 hello+'2'+'1'
            hello+'4'+'2'
            hello+'6'+'3'
    */
}
console.log(msg);

//答案是： hello189  -> "hello" + "18(9*2)" + "9"  

//2. 这一题考察的是闭包
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}
 
var f1 = Foo(),
    f2 = Foo();
f1();
f1();
f2();

//答案是： 0 1 0； 
/*
    调用一次Foo() 就会产生一个新的作用域，而每次调用产生的作用域是不相同的，所以上题中f1() 产生的作用域是1 ，然后在作用域中闭包保存了每次操作后返回的值，只要f1 不释放，i的值就一直存在。所以会返回0 1 ， 
    然而f2 是一个新的作用域。故变量已经释放，i值 变为了0 故返回0 
    两者互不影响
*/

// 3. 截取字符串的
 function subStr(oldstr,newstr) {
    if(/newstr/.test(oldstr)) {
        var newStr = oldstr(oldstr.indexof(newstr),newstr.length);
    }
 }  

//前端面试的题目：
//1.考查指针的

 int A[2][3]={1,2,3,4,5,6};,则A[1][0]和*(*(A+1)+1)的值分别是（）
 
 /*
    //答案是 4 5  
    解释： 两行三列【横向是行，竖向是列】所以矩阵是：
    [1,2,3
    4,5 6]; 这样子的 所以A[1][0] 是4 
    然后对于第二个的5 是怎么来的呢 首先 *(A+1) 是横向的移一位，竖向指针不变。 然后呢,*(A[1][0]) = 4 ; *(5)= 5 ，所以答案是4 5 
*/
 
 //考查 按位或/ 异或 / 按位与

 1100|1010,1001^1001,1001&1100分别为1110 0000 1000
/*
    按位或： “|” 两个二进制数对应位置上的数字相或【只要其中有一个是1 则为1 】
    按位与： “&” 两个二进制数对应位置上的数字相与【两个都是1 才会是1】
    按位异或： “^” 两个二进制数字对应位置上面的数字都为1 或者都为0 的时候返回0 【也就是说不相同的时候返回的是1】
*/
 
//3. 系统的“颠簸”是？ 
 答： 是不作处理的计算机活动，通常是因为内存或者其他资源耗尽或者有限而无法完成索要执行的动作
 
 //4. 线程和进程：

线程共享的内容包括：
    1. 进程代码段
    2. 进程的共有数据【利用这些数据，很容易的实现相互之间的通讯】
    3. 进程打开文件的描述符
    4. 信号的处理器
    5. 进程的当前目录
    6. 进程的用户ID和进程组ID
线程独有的内容：
    1. 线程ID
    2. 寄存器组的值
    3. 现成的堆栈
    4. 错误的代码
    5. 线程的信号屏蔽码
//5. 
    16 14 10 8 7 9 3 2 4 1 这列数字符合的是“大堆栈”

    /*
        大顶堆：在 n 位置上的数要比在2N+1和2N+2位置上的数字大 
    */
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
