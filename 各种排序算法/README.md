<h1 style="color:#20B2AA">各种排序算法</h1>

<h2 style="color:#20B2AA">1.快速排序</h2>

1. 思路：
    1. 在数据集之中，选择一个元素作为基准(pivot);
    2. 所有小于“基准”的元素，都移到“基准”的左边，所有大于“基准”的元素，都移到“基准”的右边
    3. 对“基准”左边和右边的两个子集， 不断的重复第一步和第二步，直到所有的自己只剩下一个元素为止。
    4. 重复步骤1~3.直到排序完成。
    
<h2 style="color:#20B2AA">2.冒泡排序</h2>
    
1. 思路：
    1. 比较相邻的元素，如果第一个比第二个大，就交换它们两个
    2. 对每一对相邻的元素做同样的工作，从开始第一队到结尾的最后一对，这样在最后的元素应该会是最大的数
    3. 针对所有的元素重复以上的步骤，除了最后一个。

2. 时间复杂度为： o(n^2)
    
<h2 style="color:#20B2AA">3. 插入排序</h2>

1. 思路： 对于未排序的数据，在已排序的序列中从后向前遍历，找到相应的位置插入，在从后向前的扫描过程中们需要反复把已排序的元素向后挪位，为新的元素提供插入的空间
    1. 从第一个元素开始，该元素可以认为已经被排序
    2. 去除下一个元素，在已经排序号的元素序列里面从后向前扫描
    3. 如果该元素(已排序)大于新元素，将该元素(已排序)的挪到下一个位置。
    4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
    5. 将新元素插入到该位置。
    6. 重复步骤2~5
        
<h2 style="color:#20B2AA">4. 二分排序</h2>

1. 思路： 在直接插入的排序算法上进行改动较小的排序算法，其与直接插入的排序算法的不同就在于查找插入位置的时候使用的是二分查找的方法，在速度上有一定的提升
    1. 从第一个元素开始，认为该元素已经被排序
    2. 去除下一个元素，在已经排好的元素序列中进行二分查找，找到第一个比它大的数的位置
    3. 将新元素插入到该位置后，
    4. 重复2~3
    
<h2 style="color:#20B2AA">5. 选择排序</h2>

1. 思路：
    1. 首先在末序序列中找到最大(最小)的元素，存放到排序序列的起始位置，然后，再从剩余的未排序的元素中继续寻找最大(最小)的元素，然后放到已排序的序列的末尾，直至所有元素均排序完成
2. 实现：
    1. 初始状态是无序区为所有的元素，有序区为0；
    2. 第i趟时： 当前有序区为[1...i-1],无序区为[i...n]. 该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；n-1趟结束，数组有序化了。

